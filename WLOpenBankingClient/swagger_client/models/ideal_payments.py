
"""Open Banking Reach + AIS  PIS

# REACH The Reach Directory is used to get the a list of ASPSP's which can be reached for a  specific Service. **Sandbox** The following authorization token can be used to test in the sandbox (unlike a real token this one doesn't expire) 97fb13a74c712d8c7a50476e71769eaf  # AIS There are several possible flows (sequence of API calls) to obtain a consent before Account Information data can be retrieved. Which API's are required depend on the ASPSP (the bank of the PSU) and the chosen strong customer authentication approach. The response of an API call will indicate in the Links section which next API call is required to complete the consent request.  **Sandbox** Several AspspId's are available to test specific account information scenario's, see sandbox     documentation. The following authorization token can be used to test in the sandbox (unlike a real token this one     doesn't expire) **d5bd895a4080dbbb469a207460b6fca**  # PIS There are several flows (sequence of API calls) to complete a payment. Which API's are required depend on the choosen `PaymentProduct`, ASPSP (debtor bank) and the chosen strong customer authentication approach. The response of an API call will indicate in the 'Links' section which next API call is required to complete the payment. Both PSD2 and IDEAL payments are supported. **Sandbox** Several AspspId's are available to test specific PSD2 payment initiation scenario's, see sandbox documentation.  The following authorization token can be used to test in the sandbox (unlike a real token this one doesn't expire): **97fb13a74c712d8c7a50476e71769eaf**   # noqa: E501

OpenAPI spec version: 3.2.0 + 3.6.0 + 3.7.0
    
Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six


class IDEALPayments:
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'use_debtor_token': 'bool',
        'debtor_token_callback_url': 'str',
        'flow_type': 'str',
        'expected_checkout_data': 'IDEALPaymentsExpectedCheckoutData'
    }

    attribute_map = {
        'use_debtor_token': 'UseDebtorToken',
        'debtor_token_callback_url': 'DebtorTokenCallbackUrl',
        'flow_type': 'FlowType',
        'expected_checkout_data': 'ExpectedCheckoutData'
    }

    def __init__(self, use_debtor_token=False, debtor_token_callback_url=None, flow_type='Standard', expected_checkout_data=None):  # noqa: E501
        """IDEALPayments - a model defined in Swagger"""  # noqa: E501
        self._use_debtor_token = None
        self._debtor_token_callback_url = None
        self._flow_type = None
        self._expected_checkout_data = None
        self.discriminator = None
        if use_debtor_token is not None:
            self.use_debtor_token = use_debtor_token
        if debtor_token_callback_url is not None:
            self.debtor_token_callback_url = debtor_token_callback_url
        if flow_type is not None:
            self.flow_type = flow_type
        if expected_checkout_data is not None:
            self.expected_checkout_data = expected_checkout_data

    @property
    def use_debtor_token(self):
        """Gets the use_debtor_token of this IDEALPayments.  # noqa: E501

        Identifies whether the debtor token generated by Access Point should be used   # noqa: E501

        :return: The use_debtor_token of this IDEALPayments.  # noqa: E501
        :rtype: bool
        """
        return self._use_debtor_token

    @use_debtor_token.setter
    def use_debtor_token(self, use_debtor_token):
        """Sets the use_debtor_token of this IDEALPayments.

        Identifies whether the debtor token generated by Access Point should be used   # noqa: E501

        :param use_debtor_token: The use_debtor_token of this IDEALPayments.  # noqa: E501
        :type: bool
        """

        self._use_debtor_token = use_debtor_token

    @property
    def debtor_token_callback_url(self):
        """Gets the debtor_token_callback_url of this IDEALPayments.  # noqa: E501

        The URL which will be used by the notification service post /debtorToken API to send  the debtor token provided by the iDEAL Hub. The URL should end with the version number of the notification service. This way the Initiating Party can influence which version of the notification service is used to send the request. At the moment only '/v3' is available. The DebtorTokenCallbackUrl can also be set in the Initiating Party service subscription.               # noqa: E501

        :return: The debtor_token_callback_url of this IDEALPayments.  # noqa: E501
        :rtype: str
        """
        return self._debtor_token_callback_url

    @debtor_token_callback_url.setter
    def debtor_token_callback_url(self, debtor_token_callback_url):
        """Sets the debtor_token_callback_url of this IDEALPayments.

        The URL which will be used by the notification service post /debtorToken API to send  the debtor token provided by the iDEAL Hub. The URL should end with the version number of the notification service. This way the Initiating Party can influence which version of the notification service is used to send the request. At the moment only '/v3' is available. The DebtorTokenCallbackUrl can also be set in the Initiating Party service subscription.               # noqa: E501

        :param debtor_token_callback_url: The debtor_token_callback_url of this IDEALPayments.  # noqa: E501
        :type: str
        """

        self._debtor_token_callback_url = debtor_token_callback_url

    @property
    def flow_type(self):
        """Gets the flow_type of this IDEALPayments.  # noqa: E501

        Transaction flow which the Merchant/CPSP desires to initiate. * _Standard_ - Used for normal iDEAL transactions. * _FastCheckout_ - Used for initiating the fast checkout flow where the debtor will be requested to provide checkout details which in turn iDEAL provides them to the merchant via a callback eventually.  # noqa: E501

        :return: The flow_type of this IDEALPayments.  # noqa: E501
        :rtype: str
        """
        return self._flow_type

    @flow_type.setter
    def flow_type(self, flow_type):
        """Sets the flow_type of this IDEALPayments.

        Transaction flow which the Merchant/CPSP desires to initiate. * _Standard_ - Used for normal iDEAL transactions. * _FastCheckout_ - Used for initiating the fast checkout flow where the debtor will be requested to provide checkout details which in turn iDEAL provides them to the merchant via a callback eventually.  # noqa: E501

        :param flow_type: The flow_type of this IDEALPayments.  # noqa: E501
        :type: str
        """
        allowed_values = ["Standard", "FastCheckout"]  # noqa: E501
        if flow_type not in allowed_values:
            raise ValueError(
                f"Invalid value for `flow_type` ({flow_type}), must be one of {allowed_values}"  # noqa: E501

            )

        self._flow_type = flow_type

    @property
    def expected_checkout_data(self):
        """Gets the expected_checkout_data of this IDEALPayments.  # noqa: E501

        :return: The expected_checkout_data of this IDEALPayments.  # noqa: E501
        :rtype: IDEALPaymentsExpectedCheckoutData
        """
        return self._expected_checkout_data

    @expected_checkout_data.setter
    def expected_checkout_data(self, expected_checkout_data):
        """Sets the expected_checkout_data of this IDEALPayments.

        :param expected_checkout_data: The expected_checkout_data of this IDEALPayments.  # noqa: E501
        :type: IDEALPaymentsExpectedCheckoutData
        """

        self._expected_checkout_data = expected_checkout_data

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(IDEALPayments, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, IDEALPayments):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
