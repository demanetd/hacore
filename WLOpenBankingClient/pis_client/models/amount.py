# coding: utf-8

"""
    Open Banking Payment Initiation Service

    ### Introduction There are several flows (sequence of API calls) to complete a payment. Which API's are required depend on the choosen `PaymentProduct`, ASPSP (debtor bank) and the chosen strong customer authentication approach. The response of an API call will indicate in the 'Links' section which next API call is required to complete the payment. Both PSD2 and IDEAL payments are supported.  #### PSD2 Sandbox Several AspspId's are available to test specific PSD2 payment initiation scenario's, see sandbox documentation.  The following authorization token can be used to test in the sandbox (unlike a real token this one doesn't expire): **97fb13a74c712d8c7a50476e71769eaf**   # noqa: E501

    OpenAPI spec version: 3.9.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class Amount(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'type': 'str',
        'amount': 'str',
        'maximum_amount': 'str',
        'minimum_amount': 'str',
        'currency': 'str',
        'amount_breakdown': 'AmountBreakdown'
    }

    attribute_map = {
        'type': 'Type',
        'amount': 'Amount',
        'maximum_amount': 'MaximumAmount',
        'minimum_amount': 'MinimumAmount',
        'currency': 'Currency',
        'amount_breakdown': 'AmountBreakdown'
    }

    def __init__(self, type='Fixed', amount=None, maximum_amount=None, minimum_amount=None, currency='EUR', amount_breakdown=None):  # noqa: E501
        """Amount - a model defined in Swagger"""  # noqa: E501
        self._type = None
        self._amount = None
        self._maximum_amount = None
        self._minimum_amount = None
        self._currency = None
        self._amount_breakdown = None
        self.discriminator = None
        if type is not None:
            self.type = type
        self.amount = amount
        if maximum_amount is not None:
            self.maximum_amount = maximum_amount
        if minimum_amount is not None:
            self.minimum_amount = minimum_amount
        if currency is not None:
            self.currency = currency
        if amount_breakdown is not None:
            self.amount_breakdown = amount_breakdown

    @property
    def type(self):
        """Gets the type of this Amount.  # noqa: E501

        * _Fixed_ - The amount defined by the merchant can not be changed by the user * _Change_ - The amount defined by the merchant can be changed by the user within the defined bounds. Currently can be used only for iDEAL Payments * _Define_ - The amount needs to be defined by the user. Currently can be used only for iDEAL Payments  # noqa: E501

        :return: The type of this Amount.  # noqa: E501
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this Amount.

        * _Fixed_ - The amount defined by the merchant can not be changed by the user * _Change_ - The amount defined by the merchant can be changed by the user within the defined bounds. Currently can be used only for iDEAL Payments * _Define_ - The amount needs to be defined by the user. Currently can be used only for iDEAL Payments  # noqa: E501

        :param type: The type of this Amount.  # noqa: E501
        :type: str
        """
        allowed_values = ["Fixed", "Change", "Define"]  # noqa: E501
        if type not in allowed_values:
            raise ValueError(
                "Invalid value for `type` ({0}), must be one of {1}"  # noqa: E501
                .format(type, allowed_values)
            )

        self._type = type

    @property
    def amount(self):
        """Gets the amount of this Amount.  # noqa: E501

        Amount of the payment. The decimal separator is a dot.   # noqa: E501

        :return: The amount of this Amount.  # noqa: E501
        :rtype: str
        """
        return self._amount

    @amount.setter
    def amount(self, amount):
        """Sets the amount of this Amount.

        Amount of the payment. The decimal separator is a dot.   # noqa: E501

        :param amount: The amount of this Amount.  # noqa: E501
        :type: str
        """
        if amount is None:
            raise ValueError("Invalid value for `amount`, must not be `None`")  # noqa: E501

        self._amount = amount

    @property
    def maximum_amount(self):
        """Gets the maximum_amount of this Amount.  # noqa: E501

        Conditionally used for amount type Change or Define. The value in case of Change should be greater than or equal to the amount value. In case of Fixed, this value will be ignored.  # noqa: E501

        :return: The maximum_amount of this Amount.  # noqa: E501
        :rtype: str
        """
        return self._maximum_amount

    @maximum_amount.setter
    def maximum_amount(self, maximum_amount):
        """Sets the maximum_amount of this Amount.

        Conditionally used for amount type Change or Define. The value in case of Change should be greater than or equal to the amount value. In case of Fixed, this value will be ignored.  # noqa: E501

        :param maximum_amount: The maximum_amount of this Amount.  # noqa: E501
        :type: str
        """

        self._maximum_amount = maximum_amount

    @property
    def minimum_amount(self):
        """Gets the minimum_amount of this Amount.  # noqa: E501

        Conditionally used for amount type Change or Define. The value in case of Change should be less than or equal to the amount. In case of Fixed, this value will be ignored.  # noqa: E501

        :return: The minimum_amount of this Amount.  # noqa: E501
        :rtype: str
        """
        return self._minimum_amount

    @minimum_amount.setter
    def minimum_amount(self, minimum_amount):
        """Sets the minimum_amount of this Amount.

        Conditionally used for amount type Change or Define. The value in case of Change should be less than or equal to the amount. In case of Fixed, this value will be ignored.  # noqa: E501

        :param minimum_amount: The minimum_amount of this Amount.  # noqa: E501
        :type: str
        """

        self._minimum_amount = minimum_amount

    @property
    def currency(self):
        """Gets the currency of this Amount.  # noqa: E501

        Currency of the payment. ISO 4217 currency codes should be used. For iDEAL only EUR is possible   # noqa: E501

        :return: The currency of this Amount.  # noqa: E501
        :rtype: str
        """
        return self._currency

    @currency.setter
    def currency(self, currency):
        """Sets the currency of this Amount.

        Currency of the payment. ISO 4217 currency codes should be used. For iDEAL only EUR is possible   # noqa: E501

        :param currency: The currency of this Amount.  # noqa: E501
        :type: str
        """

        self._currency = currency

    @property
    def amount_breakdown(self):
        """Gets the amount_breakdown of this Amount.  # noqa: E501


        :return: The amount_breakdown of this Amount.  # noqa: E501
        :rtype: AmountBreakdown
        """
        return self._amount_breakdown

    @amount_breakdown.setter
    def amount_breakdown(self, amount_breakdown):
        """Sets the amount_breakdown of this Amount.


        :param amount_breakdown: The amount_breakdown of this Amount.  # noqa: E501
        :type: AmountBreakdown
        """

        self._amount_breakdown = amount_breakdown

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(Amount, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Amount):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
