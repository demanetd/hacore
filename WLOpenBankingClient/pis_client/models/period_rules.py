# coding: utf-8

"""
    Open Banking Payment Initiation Service

    ### Introduction There are several flows (sequence of API calls) to complete a payment. Which API's are required depend on the choosen `PaymentProduct`, ASPSP (debtor bank) and the chosen strong customer authentication approach. The response of an API call will indicate in the 'Links' section which next API call is required to complete the payment. Both PSD2 and IDEAL payments are supported.  #### PSD2 Sandbox Several AspspId's are available to test specific PSD2 payment initiation scenario's, see sandbox documentation.  The following authorization token can be used to test in the sandbox (unlike a real token this one doesn't expire): **97fb13a74c712d8c7a50476e71769eaf**   # noqa: E501

    OpenAPI spec version: 3.9.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class PeriodRules(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'start_date_time': 'datetime',
        'execution_rule': 'str',
        'end_date': 'str',
        'frequency': 'str',
        'day_of_execution': 'int'
    }

    attribute_map = {
        'start_date_time': 'StartDateTime',
        'execution_rule': 'ExecutionRule',
        'end_date': 'EndDate',
        'frequency': 'Frequency',
        'day_of_execution': 'DayOfExecution'
    }

    def __init__(self, start_date_time=None, execution_rule=None, end_date=None, frequency=None, day_of_execution=None):  # noqa: E501
        """PeriodRules - a model defined in Swagger"""  # noqa: E501
        self._start_date_time = None
        self._execution_rule = None
        self._end_date = None
        self._frequency = None
        self._day_of_execution = None
        self.discriminator = None
        self.start_date_time = start_date_time
        if execution_rule is not None:
            self.execution_rule = execution_rule
        if end_date is not None:
            self.end_date = end_date
        self.frequency = frequency
        if day_of_execution is not None:
            self.day_of_execution = day_of_execution

    @property
    def start_date_time(self):
        """Gets the start_date_time of this PeriodRules.  # noqa: E501

        Date of first occurence. ISO 8601 DateTime.   # noqa: E501

        :return: The start_date_time of this PeriodRules.  # noqa: E501
        :rtype: datetime
        """
        return self._start_date_time

    @start_date_time.setter
    def start_date_time(self, start_date_time):
        """Sets the start_date_time of this PeriodRules.

        Date of first occurence. ISO 8601 DateTime.   # noqa: E501

        :param start_date_time: The start_date_time of this PeriodRules.  # noqa: E501
        :type: datetime
        """
        if start_date_time is None:
            raise ValueError("Invalid value for `start_date_time`, must not be `None`")  # noqa: E501

        self._start_date_time = start_date_time

    @property
    def execution_rule(self):
        """Gets the execution_rule of this PeriodRules.  # noqa: E501

        Specifies the execution rule to follow in the cases when the computed execution dates cannot be processed (e.g. bank holidays). The default value sent to the ASPSP will be FWNG.   # noqa: E501

        :return: The execution_rule of this PeriodRules.  # noqa: E501
        :rtype: str
        """
        return self._execution_rule

    @execution_rule.setter
    def execution_rule(self, execution_rule):
        """Sets the execution_rule of this PeriodRules.

        Specifies the execution rule to follow in the cases when the computed execution dates cannot be processed (e.g. bank holidays). The default value sent to the ASPSP will be FWNG.   # noqa: E501

        :param execution_rule: The execution_rule of this PeriodRules.  # noqa: E501
        :type: str
        """
        allowed_values = ["FWNG", "PREC"]  # noqa: E501
        if execution_rule not in allowed_values:
            raise ValueError(
                "Invalid value for `execution_rule` ({0}), must be one of {1}"  # noqa: E501
                .format(execution_rule, allowed_values)
            )

        self._execution_rule = execution_rule

    @property
    def end_date(self):
        """Gets the end_date of this PeriodRules.  # noqa: E501

        Optional date for closing the periodic payment. Must be given in ISO LOCAL DATE format.   # noqa: E501

        :return: The end_date of this PeriodRules.  # noqa: E501
        :rtype: str
        """
        return self._end_date

    @end_date.setter
    def end_date(self, end_date):
        """Sets the end_date of this PeriodRules.

        Optional date for closing the periodic payment. Must be given in ISO LOCAL DATE format.   # noqa: E501

        :param end_date: The end_date of this PeriodRules.  # noqa: E501
        :type: str
        """

        self._end_date = end_date

    @property
    def frequency(self):
        """Gets the frequency of this PeriodRules.  # noqa: E501

        Specifies the frequency of the payment in order to compute further execution dates.   # noqa: E501

        :return: The frequency of this PeriodRules.  # noqa: E501
        :rtype: str
        """
        return self._frequency

    @frequency.setter
    def frequency(self, frequency):
        """Sets the frequency of this PeriodRules.

        Specifies the frequency of the payment in order to compute further execution dates.   # noqa: E501

        :param frequency: The frequency of this PeriodRules.  # noqa: E501
        :type: str
        """
        if frequency is None:
            raise ValueError("Invalid value for `frequency`, must not be `None`")  # noqa: E501
        allowed_values = ["DAIL", "WEEK", "TOWK", "MNTH", "TOMN", "QUTR", "SEMI", "YEAR"]  # noqa: E501
        if frequency not in allowed_values:
            raise ValueError(
                "Invalid value for `frequency` ({0}), must be one of {1}"  # noqa: E501
                .format(frequency, allowed_values)
            )

        self._frequency = frequency

    @property
    def day_of_execution(self):
        """Gets the day_of_execution of this PeriodRules.  # noqa: E501

        Sepcifies the day of execution. Day of the month 1...31. Applicable only for MNTH or higher.   # noqa: E501

        :return: The day_of_execution of this PeriodRules.  # noqa: E501
        :rtype: int
        """
        return self._day_of_execution

    @day_of_execution.setter
    def day_of_execution(self, day_of_execution):
        """Sets the day_of_execution of this PeriodRules.

        Sepcifies the day of execution. Day of the month 1...31. Applicable only for MNTH or higher.   # noqa: E501

        :param day_of_execution: The day_of_execution of this PeriodRules.  # noqa: E501
        :type: int
        """

        self._day_of_execution = day_of_execution

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(PeriodRules, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, PeriodRules):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
