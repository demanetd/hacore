# coding: utf-8

"""
    Open Banking Account Information V3

    There are several possible flows (sequence of API calls) to obtain a consent before Account Information data can be retrieved. Which API's are required depend on the ASPSP (the bank of the PSU) and the chosen strong customer authentication approach. The response of an API call will indicate in the 'Links' section which next API call is required to complete the consent request.  #### PSD2 Sandbox  Several AspspId's are available to test specific account information scenario's, see sandbox documentation.  The following authorization token can be used to test in the sandbox (unlike a real token this one doesn't expire): **d5bd895a4080dbbb469a207460b6fca**   # noqa: E501

    OpenAPI spec version: 3.7.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class Balance(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'balance_name': 'str',
        'amount': 'Amount',
        'currency': 'Currency',
        'balance_type': 'BalanceType',
        'credit_debit_indicator': 'CreditDebitIndicator',
        'last_commited_transaction': 'str',
        'credit_line': 'list[CreditLine]',
        '_date': 'str',
        'last_change_date_time': 'datetime'
    }

    attribute_map = {
        'balance_name': 'BalanceName',
        'amount': 'Amount',
        'currency': 'Currency',
        'balance_type': 'BalanceType',
        'credit_debit_indicator': 'CreditDebitIndicator',
        'last_commited_transaction': 'LastCommitedTransaction',
        'credit_line': 'CreditLine',
        '_date': 'Date',
        'last_change_date_time': 'LastChangeDateTime'
    }

    def __init__(self, balance_name=None, amount=None, currency=None, balance_type=None, credit_debit_indicator=None, last_commited_transaction=None, credit_line=None, _date=None, last_change_date_time=None):  # noqa: E501
        """Balance - a model defined in Swagger"""  # noqa: E501
        self._balance_name = None
        self._amount = None
        self._currency = None
        self._balance_type = None
        self._credit_debit_indicator = None
        self._last_commited_transaction = None
        self._credit_line = None
        self.__date = None
        self._last_change_date_time = None
        self.discriminator = None
        if balance_name is not None:
            self.balance_name = balance_name
        self.amount = amount
        self.currency = currency
        self.balance_type = balance_type
        self.credit_debit_indicator = credit_debit_indicator
        if last_commited_transaction is not None:
            self.last_commited_transaction = last_commited_transaction
        if credit_line is not None:
            self.credit_line = credit_line
        if _date is not None:
            self._date = _date
        if last_change_date_time is not None:
            self.last_change_date_time = last_change_date_time

    @property
    def balance_name(self):
        """Gets the balance_name of this Balance.  # noqa: E501

        Label of the balance.   # noqa: E501

        :return: The balance_name of this Balance.  # noqa: E501
        :rtype: str
        """
        return self._balance_name

    @balance_name.setter
    def balance_name(self, balance_name):
        """Sets the balance_name of this Balance.

        Label of the balance.   # noqa: E501

        :param balance_name: The balance_name of this Balance.  # noqa: E501
        :type: str
        """

        self._balance_name = balance_name

    @property
    def amount(self):
        """Gets the amount of this Balance.  # noqa: E501


        :return: The amount of this Balance.  # noqa: E501
        :rtype: Amount
        """
        return self._amount

    @amount.setter
    def amount(self, amount):
        """Sets the amount of this Balance.


        :param amount: The amount of this Balance.  # noqa: E501
        :type: Amount
        """
        if amount is None:
            raise ValueError("Invalid value for `amount`, must not be `None`")  # noqa: E501

        self._amount = amount

    @property
    def currency(self):
        """Gets the currency of this Balance.  # noqa: E501


        :return: The currency of this Balance.  # noqa: E501
        :rtype: Currency
        """
        return self._currency

    @currency.setter
    def currency(self, currency):
        """Sets the currency of this Balance.


        :param currency: The currency of this Balance.  # noqa: E501
        :type: Currency
        """
        if currency is None:
            raise ValueError("Invalid value for `currency`, must not be `None`")  # noqa: E501

        self._currency = currency

    @property
    def balance_type(self):
        """Gets the balance_type of this Balance.  # noqa: E501


        :return: The balance_type of this Balance.  # noqa: E501
        :rtype: BalanceType
        """
        return self._balance_type

    @balance_type.setter
    def balance_type(self, balance_type):
        """Sets the balance_type of this Balance.


        :param balance_type: The balance_type of this Balance.  # noqa: E501
        :type: BalanceType
        """
        if balance_type is None:
            raise ValueError("Invalid value for `balance_type`, must not be `None`")  # noqa: E501

        self._balance_type = balance_type

    @property
    def credit_debit_indicator(self):
        """Gets the credit_debit_indicator of this Balance.  # noqa: E501


        :return: The credit_debit_indicator of this Balance.  # noqa: E501
        :rtype: CreditDebitIndicator
        """
        return self._credit_debit_indicator

    @credit_debit_indicator.setter
    def credit_debit_indicator(self, credit_debit_indicator):
        """Sets the credit_debit_indicator of this Balance.


        :param credit_debit_indicator: The credit_debit_indicator of this Balance.  # noqa: E501
        :type: CreditDebitIndicator
        """
        if credit_debit_indicator is None:
            raise ValueError("Invalid value for `credit_debit_indicator`, must not be `None`")  # noqa: E501

        self._credit_debit_indicator = credit_debit_indicator

    @property
    def last_commited_transaction(self):
        """Gets the last_commited_transaction of this Balance.  # noqa: E501

        entryReference of the last committed transaction to support the Initiating Party in identifying whether all PSU transactions are already known.   # noqa: E501

        :return: The last_commited_transaction of this Balance.  # noqa: E501
        :rtype: str
        """
        return self._last_commited_transaction

    @last_commited_transaction.setter
    def last_commited_transaction(self, last_commited_transaction):
        """Sets the last_commited_transaction of this Balance.

        entryReference of the last committed transaction to support the Initiating Party in identifying whether all PSU transactions are already known.   # noqa: E501

        :param last_commited_transaction: The last_commited_transaction of this Balance.  # noqa: E501
        :type: str
        """

        self._last_commited_transaction = last_commited_transaction

    @property
    def credit_line(self):
        """Gets the credit_line of this Balance.  # noqa: E501


        :return: The credit_line of this Balance.  # noqa: E501
        :rtype: list[CreditLine]
        """
        return self._credit_line

    @credit_line.setter
    def credit_line(self, credit_line):
        """Sets the credit_line of this Balance.


        :param credit_line: The credit_line of this Balance.  # noqa: E501
        :type: list[CreditLine]
        """

        self._credit_line = credit_line

    @property
    def _date(self):
        """Gets the _date of this Balance.  # noqa: E501

        Indicates the date of the balance. Date in ISO 8601 format yyyy -MM-dd.   # noqa: E501

        :return: The _date of this Balance.  # noqa: E501
        :rtype: str
        """
        return self.__date

    @_date.setter
    def _date(self, _date):
        """Sets the _date of this Balance.

        Indicates the date of the balance. Date in ISO 8601 format yyyy -MM-dd.   # noqa: E501

        :param _date: The _date of this Balance.  # noqa: E501
        :type: str
        """

        self.__date = _date

    @property
    def last_change_date_time(self):
        """Gets the last_change_date_time of this Balance.  # noqa: E501

        Timestamp of the last change of the balance amount. This data element might be used to indicate e.g. with the expected or booked balance that no action is known on the account, which is not yet booked.   # noqa: E501

        :return: The last_change_date_time of this Balance.  # noqa: E501
        :rtype: datetime
        """
        return self._last_change_date_time

    @last_change_date_time.setter
    def last_change_date_time(self, last_change_date_time):
        """Sets the last_change_date_time of this Balance.

        Timestamp of the last change of the balance amount. This data element might be used to indicate e.g. with the expected or booked balance that no action is known on the account, which is not yet booked.   # noqa: E501

        :param last_change_date_time: The last_change_date_time of this Balance.  # noqa: E501
        :type: datetime
        """

        self._last_change_date_time = last_change_date_time

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(Balance, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Balance):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
