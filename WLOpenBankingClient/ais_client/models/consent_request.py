# coding: utf-8

"""
    Open Banking Account Information V3

    There are several possible flows (sequence of API calls) to obtain a consent before Account Information data can be retrieved. Which API's are required depend on the ASPSP (the bank of the PSU) and the chosen strong customer authentication approach. The response of an API call will indicate in the 'Links' section which next API call is required to complete the consent request.  #### PSD2 Sandbox  Several AspspId's are available to test specific account information scenario's, see sandbox documentation.  The following authorization token can be used to test in the sandbox (unlike a real token this one doesn't expire): **d5bd895a4080dbbb469a207460b6fca**   # noqa: E501

    OpenAPI spec version: 3.7.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class ConsentRequest(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'psu_data': 'PsuData',
        'use_pre_authentication': 'bool',
        'preferred_sca_method': 'list[str]',
        'permissions': 'list[PermissionEnum]',
        'details': 'ConsentDetails',
        'transaction_from_date_time': 'datetime',
        'transaction_to_date_time': 'datetime'
    }

    attribute_map = {
        'psu_data': 'PsuData',
        'use_pre_authentication': 'UsePreAuthentication',
        'preferred_sca_method': 'PreferredScaMethod',
        'permissions': 'Permissions',
        'details': 'Details',
        'transaction_from_date_time': 'TransactionFromDateTime',
        'transaction_to_date_time': 'TransactionToDateTime'
    }

    def __init__(self, psu_data=None, use_pre_authentication=False, preferred_sca_method=None, permissions=None, details=None, transaction_from_date_time=None, transaction_to_date_time=None):  # noqa: E501
        """ConsentRequest - a model defined in Swagger"""  # noqa: E501
        self._psu_data = None
        self._use_pre_authentication = None
        self._preferred_sca_method = None
        self._permissions = None
        self._details = None
        self._transaction_from_date_time = None
        self._transaction_to_date_time = None
        self.discriminator = None
        if psu_data is not None:
            self.psu_data = psu_data
        if use_pre_authentication is not None:
            self.use_pre_authentication = use_pre_authentication
        if preferred_sca_method is not None:
            self.preferred_sca_method = preferred_sca_method
        if permissions is not None:
            self.permissions = permissions
        if details is not None:
            self.details = details
        if transaction_from_date_time is not None:
            self.transaction_from_date_time = transaction_from_date_time
        if transaction_to_date_time is not None:
            self.transaction_to_date_time = transaction_to_date_time

    @property
    def psu_data(self):
        """Gets the psu_data of this ConsentRequest.  # noqa: E501


        :return: The psu_data of this ConsentRequest.  # noqa: E501
        :rtype: PsuData
        """
        return self._psu_data

    @psu_data.setter
    def psu_data(self, psu_data):
        """Sets the psu_data of this ConsentRequest.


        :param psu_data: The psu_data of this ConsentRequest.  # noqa: E501
        :type: PsuData
        """

        self._psu_data = psu_data

    @property
    def use_pre_authentication(self):
        """Gets the use_pre_authentication of this ConsentRequest.  # noqa: E501

        This field is only applicable for ASPSP's which support pre-authentication. It can also be filled in consent requests toward other ASPSP's, but the value will then be ignored.  * If set to true the Open Banking Service will store the pre-authentication token for use with future consent requests. This will only work if also a PsuId is provided which is stored in the Open Banking Service. <br>  * If set to false the pre-authentication token will only be used to finish one consent request. After which it will be discarded.   # noqa: E501

        :return: The use_pre_authentication of this ConsentRequest.  # noqa: E501
        :rtype: bool
        """
        return self._use_pre_authentication

    @use_pre_authentication.setter
    def use_pre_authentication(self, use_pre_authentication):
        """Sets the use_pre_authentication of this ConsentRequest.

        This field is only applicable for ASPSP's which support pre-authentication. It can also be filled in consent requests toward other ASPSP's, but the value will then be ignored.  * If set to true the Open Banking Service will store the pre-authentication token for use with future consent requests. This will only work if also a PsuId is provided which is stored in the Open Banking Service. <br>  * If set to false the pre-authentication token will only be used to finish one consent request. After which it will be discarded.   # noqa: E501

        :param use_pre_authentication: The use_pre_authentication of this ConsentRequest.  # noqa: E501
        :type: bool
        """

        self._use_pre_authentication = use_pre_authentication

    @property
    def preferred_sca_method(self):
        """Gets the preferred_sca_method of this ConsentRequest.  # noqa: E501


        :return: The preferred_sca_method of this ConsentRequest.  # noqa: E501
        :rtype: list[str]
        """
        return self._preferred_sca_method

    @preferred_sca_method.setter
    def preferred_sca_method(self, preferred_sca_method):
        """Sets the preferred_sca_method of this ConsentRequest.


        :param preferred_sca_method: The preferred_sca_method of this ConsentRequest.  # noqa: E501
        :type: list[str]
        """
        allowed_values = ["Redirect", "Decoupled", "Embedded"]  # noqa: E501
        if not set(preferred_sca_method).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `preferred_sca_method` [{0}], must be a subset of [{1}]"  # noqa: E501
                .format(", ".join(map(str, set(preferred_sca_method) - set(allowed_values))),  # noqa: E501
                        ", ".join(map(str, allowed_values)))
            )

        self._preferred_sca_method = preferred_sca_method

    @property
    def permissions(self):
        """Gets the permissions of this ConsentRequest.  # noqa: E501


        :return: The permissions of this ConsentRequest.  # noqa: E501
        :rtype: list[PermissionEnum]
        """
        return self._permissions

    @permissions.setter
    def permissions(self, permissions):
        """Sets the permissions of this ConsentRequest.


        :param permissions: The permissions of this ConsentRequest.  # noqa: E501
        :type: list[PermissionEnum]
        """

        self._permissions = permissions

    @property
    def details(self):
        """Gets the details of this ConsentRequest.  # noqa: E501


        :return: The details of this ConsentRequest.  # noqa: E501
        :rtype: ConsentDetails
        """
        return self._details

    @details.setter
    def details(self, details):
        """Sets the details of this ConsentRequest.


        :param details: The details of this ConsentRequest.  # noqa: E501
        :type: ConsentDetails
        """

        self._details = details

    @property
    def transaction_from_date_time(self):
        """Gets the transaction_from_date_time of this ConsentRequest.  # noqa: E501

        Specified start date and time for the transaction query period. If this is not populated, the start date will be open ended, and data will be returned from the earliest available transaction.  # noqa: E501

        :return: The transaction_from_date_time of this ConsentRequest.  # noqa: E501
        :rtype: datetime
        """
        return self._transaction_from_date_time

    @transaction_from_date_time.setter
    def transaction_from_date_time(self, transaction_from_date_time):
        """Sets the transaction_from_date_time of this ConsentRequest.

        Specified start date and time for the transaction query period. If this is not populated, the start date will be open ended, and data will be returned from the earliest available transaction.  # noqa: E501

        :param transaction_from_date_time: The transaction_from_date_time of this ConsentRequest.  # noqa: E501
        :type: datetime
        """

        self._transaction_from_date_time = transaction_from_date_time

    @property
    def transaction_to_date_time(self):
        """Gets the transaction_to_date_time of this ConsentRequest.  # noqa: E501

        Specified end date and time for the transaction query period. If this is not populated, the end date will be open ended, and data will be returned to the latest available transaction.  # noqa: E501

        :return: The transaction_to_date_time of this ConsentRequest.  # noqa: E501
        :rtype: datetime
        """
        return self._transaction_to_date_time

    @transaction_to_date_time.setter
    def transaction_to_date_time(self, transaction_to_date_time):
        """Sets the transaction_to_date_time of this ConsentRequest.

        Specified end date and time for the transaction query period. If this is not populated, the end date will be open ended, and data will be returned to the latest available transaction.  # noqa: E501

        :param transaction_to_date_time: The transaction_to_date_time of this ConsentRequest.  # noqa: E501
        :type: datetime
        """

        self._transaction_to_date_time = transaction_to_date_time

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(ConsentRequest, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, ConsentRequest):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
