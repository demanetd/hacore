# coding: utf-8

"""
Open Banking Account Information V3

There are several possible flows (sequence of API calls) to obtain a consent before Account Information data can be retrieved. Which API's are required depend on the ASPSP (the bank of the PSU) and the chosen strong customer authentication approach. The response of an API call will indicate in the 'Links' section which next API call is required to complete the consent request.  #### PSD2 Sandbox  Several AspspId's are available to test specific account information scenario's, see sandbox documentation.  The following authorization token can be used to test in the sandbox (unlike a real token this one doesn't expire): **d5bd895a4080dbbb469a207460b6fca**   # noqa: E501

OpenAPI spec version: 3.7.0

Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from ais_client.api_client import ApiClient


class AccountInformationServiceApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def accounts(
        self, psu_id, aspsp_id, x_request_id, message_create_date_time, **kwargs
    ):  # noqa: E501
        """Lists all accounts that are consented by the PSU for a specific ASPSP  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts(psu_id, aspsp_id, x_request_id, message_create_date_time, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str psu_id: This field can be filled with an ID from the Initiating Party which refers to the PSU.  (required)
        :param str aspsp_id: ASPSP ID.  (required)
        :param str x_request_id: UUID for unique request identification.  (required)
        :param datetime message_create_date_time: The message create date time.  ISO 8601 DateTime.  (required)
        :param str page: Used to retrieve a specific page in case the result is  paginated. The value can be first, last, prev, next or a  numerical value to request for a dedicated result page.
        :param int total_pages: Used to limit the number of total pages retrieved by one request, if the result is paginated by the ASPSP.
        :param str psu_ip_address: PSU Session information.  The forwarded IP Address header field consists of the corresponding HTTP request IP Address field between PSU and TPP . It shall be contained if and only if this request was actively initiated by the PSU.
        :return: GetAccountsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.accounts_with_http_info(
                psu_id, aspsp_id, x_request_id, message_create_date_time, **kwargs
            )  # noqa: E501
        else:
            (data) = self.accounts_with_http_info(
                psu_id, aspsp_id, x_request_id, message_create_date_time, **kwargs
            )  # noqa: E501
            return data

    def accounts_with_http_info(
        self, psu_id, aspsp_id, x_request_id, message_create_date_time, **kwargs
    ):  # noqa: E501
        """Lists all accounts that are consented by the PSU for a specific ASPSP  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_with_http_info(psu_id, aspsp_id, x_request_id, message_create_date_time, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str psu_id: This field can be filled with an ID from the Initiating Party which refers to the PSU.  (required)
        :param str aspsp_id: ASPSP ID.  (required)
        :param str x_request_id: UUID for unique request identification.  (required)
        :param datetime message_create_date_time: The message create date time.  ISO 8601 DateTime.  (required)
        :param str page: Used to retrieve a specific page in case the result is  paginated. The value can be first, last, prev, next or a  numerical value to request for a dedicated result page.
        :param int total_pages: Used to limit the number of total pages retrieved by one request, if the result is paginated by the ASPSP.
        :param str psu_ip_address: PSU Session information.  The forwarded IP Address header field consists of the corresponding HTTP request IP Address field between PSU and TPP . It shall be contained if and only if this request was actively initiated by the PSU.
        :return: GetAccountsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "psu_id",
            "aspsp_id",
            "x_request_id",
            "message_create_date_time",
            "page",
            "total_pages",
            "psu_ip_address",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'psu_id' is set
        if "psu_id" not in params or params["psu_id"] is None:
            raise ValueError(
                "Missing the required parameter `psu_id` when calling `accounts`"
            )  # noqa: E501
        # verify the required parameter 'aspsp_id' is set
        if "aspsp_id" not in params or params["aspsp_id"] is None:
            raise ValueError(
                "Missing the required parameter `aspsp_id` when calling `accounts`"
            )  # noqa: E501
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling `accounts`"
            )  # noqa: E501
        # verify the required parameter 'message_create_date_time' is set
        if (
            "message_create_date_time" not in params
            or params["message_create_date_time"] is None
        ):
            raise ValueError(
                "Missing the required parameter `message_create_date_time` when calling `accounts`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "psu_id" in params:
            path_params["psuId"] = params["psu_id"]  # noqa: E501
        if "aspsp_id" in params:
            path_params["aspspId"] = params["aspsp_id"]  # noqa: E501

        query_params = []
        if "page" in params:
            query_params.append(("page", params["page"]))  # noqa: E501
        if "total_pages" in params:
            query_params.append(("totalPages", params["total_pages"]))  # noqa: E501

        header_params = {}
        if "psu_ip_address" in params:
            header_params["PsuIpAddress"] = params["psu_ip_address"]  # noqa: E501
        if "x_request_id" in params:
            header_params["X-Request-ID"] = params["x_request_id"]  # noqa: E501
        if "message_create_date_time" in params:
            header_params["MessageCreateDateTime"] = params["message_create_date_time"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["Authorization"]  # noqa: E501

        return self.api_client.call_api(
            "/psus/{psuId}/aspsps/{aspspId}/accounts",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="GetAccountsResponse",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def authorisation(
        self, x_request_id, message_create_date_time, psu_id, consent_id, **kwargs
    ):  # noqa: E501
        """Start the authorisation process for a consent  # noqa: E501

        Use this operation to authorize a PSU in multilevel authorization approach.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.authorisation(x_request_id, message_create_date_time, psu_id, consent_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: UUID for unique request identification.  (required)
        :param datetime message_create_date_time: The message create date time.  ISO 8601 DateTime.  (required)
        :param str psu_id: This field can be filled with an ID from the Initiating Party which refers to the PSU.  (required)
        :param str consent_id: Id of the consent as received in the response to POST consents.  (required)
        :param ConsentAuthorisationRequest body:
        :param str psu_ip_address: PSU Session information.  The forwarded IP Address header field consists of the corresponding HTTP request IP Address field between PSU and TPP . It shall be contained if and only if this request was actively initiated by the PSU.
        :return: ConsentAuthorisationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.authorisation_with_http_info(
                x_request_id, message_create_date_time, psu_id, consent_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.authorisation_with_http_info(
                x_request_id, message_create_date_time, psu_id, consent_id, **kwargs
            )  # noqa: E501
            return data

    def authorisation_with_http_info(
        self, x_request_id, message_create_date_time, psu_id, consent_id, **kwargs
    ):  # noqa: E501
        """Start the authorisation process for a consent  # noqa: E501

        Use this operation to authorize a PSU in multilevel authorization approach.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.authorisation_with_http_info(x_request_id, message_create_date_time, psu_id, consent_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: UUID for unique request identification.  (required)
        :param datetime message_create_date_time: The message create date time.  ISO 8601 DateTime.  (required)
        :param str psu_id: This field can be filled with an ID from the Initiating Party which refers to the PSU.  (required)
        :param str consent_id: Id of the consent as received in the response to POST consents.  (required)
        :param ConsentAuthorisationRequest body:
        :param str psu_ip_address: PSU Session information.  The forwarded IP Address header field consists of the corresponding HTTP request IP Address field between PSU and TPP . It shall be contained if and only if this request was actively initiated by the PSU.
        :return: ConsentAuthorisationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "x_request_id",
            "message_create_date_time",
            "psu_id",
            "consent_id",
            "body",
            "psu_ip_address",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method authorisation" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling `authorisation`"
            )  # noqa: E501
        # verify the required parameter 'message_create_date_time' is set
        if (
            "message_create_date_time" not in params
            or params["message_create_date_time"] is None
        ):
            raise ValueError(
                "Missing the required parameter `message_create_date_time` when calling `authorisation`"
            )  # noqa: E501
        # verify the required parameter 'psu_id' is set
        if "psu_id" not in params or params["psu_id"] is None:
            raise ValueError(
                "Missing the required parameter `psu_id` when calling `authorisation`"
            )  # noqa: E501
        # verify the required parameter 'consent_id' is set
        if "consent_id" not in params or params["consent_id"] is None:
            raise ValueError(
                "Missing the required parameter `consent_id` when calling `authorisation`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "psu_id" in params:
            path_params["psuId"] = params["psu_id"]  # noqa: E501
        if "consent_id" in params:
            path_params["consentId"] = params["consent_id"]  # noqa: E501

        query_params = []

        header_params = {}
        if "psu_ip_address" in params:
            header_params["PsuIpAddress"] = params["psu_ip_address"]  # noqa: E501
        if "x_request_id" in params:
            header_params["X-Request-ID"] = params["x_request_id"]  # noqa: E501
        if "message_create_date_time" in params:
            header_params["MessageCreateDateTime"] = params["message_create_date_time"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["Authorization"]  # noqa: E501

        return self.api_client.call_api(
            "/psus/{psuId}/consents/{consentId}/authorisations",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="ConsentAuthorisationResponse",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def authorisation_update(
        self,
        x_request_id,
        message_create_date_time,
        psu_id,
        consent_id,
        authorisation_id,
        **kwargs,
    ):  # noqa: E501
        """Consent authorisation update  # noqa: E501

        Use this operation to update the authorization.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.authorisation_update(x_request_id, message_create_date_time, psu_id, consent_id, authorisation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: UUID for unique request identification.  (required)
        :param datetime message_create_date_time: The message create date time.  ISO 8601 DateTime.  (required)
        :param str psu_id: This field can be filled with an ID from the Initiating Party which refers to the PSU.  (required)
        :param str consent_id: Id of the consent as received in the response to POST consents.  (required)
        :param str authorisation_id: Id of the authorization as received in the response to the previous request in the corresponding Link.  (required)
        :param ConsentAuthorisationUpdateRequest body:
        :param str psu_ip_address: PSU Session information.  The forwarded IP Address header field consists of the corresponding HTTP request IP Address field between PSU and TPP . It shall be contained if and only if this request was actively initiated by the PSU.
        :return: ConsentAuthorisationUpdateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.authorisation_update_with_http_info(
                x_request_id,
                message_create_date_time,
                psu_id,
                consent_id,
                authorisation_id,
                **kwargs,
            )  # noqa: E501
        else:
            (data) = self.authorisation_update_with_http_info(
                x_request_id,
                message_create_date_time,
                psu_id,
                consent_id,
                authorisation_id,
                **kwargs,
            )  # noqa: E501
            return data

    def authorisation_update_with_http_info(
        self,
        x_request_id,
        message_create_date_time,
        psu_id,
        consent_id,
        authorisation_id,
        **kwargs,
    ):  # noqa: E501
        """Consent authorisation update  # noqa: E501

        Use this operation to update the authorization.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.authorisation_update_with_http_info(x_request_id, message_create_date_time, psu_id, consent_id, authorisation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: UUID for unique request identification.  (required)
        :param datetime message_create_date_time: The message create date time.  ISO 8601 DateTime.  (required)
        :param str psu_id: This field can be filled with an ID from the Initiating Party which refers to the PSU.  (required)
        :param str consent_id: Id of the consent as received in the response to POST consents.  (required)
        :param str authorisation_id: Id of the authorization as received in the response to the previous request in the corresponding Link.  (required)
        :param ConsentAuthorisationUpdateRequest body:
        :param str psu_ip_address: PSU Session information.  The forwarded IP Address header field consists of the corresponding HTTP request IP Address field between PSU and TPP . It shall be contained if and only if this request was actively initiated by the PSU.
        :return: ConsentAuthorisationUpdateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "x_request_id",
            "message_create_date_time",
            "psu_id",
            "consent_id",
            "authorisation_id",
            "body",
            "psu_ip_address",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method authorisation_update" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling `authorisation_update`"
            )  # noqa: E501
        # verify the required parameter 'message_create_date_time' is set
        if (
            "message_create_date_time" not in params
            or params["message_create_date_time"] is None
        ):
            raise ValueError(
                "Missing the required parameter `message_create_date_time` when calling `authorisation_update`"
            )  # noqa: E501
        # verify the required parameter 'psu_id' is set
        if "psu_id" not in params or params["psu_id"] is None:
            raise ValueError(
                "Missing the required parameter `psu_id` when calling `authorisation_update`"
            )  # noqa: E501
        # verify the required parameter 'consent_id' is set
        if "consent_id" not in params or params["consent_id"] is None:
            raise ValueError(
                "Missing the required parameter `consent_id` when calling `authorisation_update`"
            )  # noqa: E501
        # verify the required parameter 'authorisation_id' is set
        if "authorisation_id" not in params or params["authorisation_id"] is None:
            raise ValueError(
                "Missing the required parameter `authorisation_id` when calling `authorisation_update`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "psu_id" in params:
            path_params["psuId"] = params["psu_id"]  # noqa: E501
        if "consent_id" in params:
            path_params["consentId"] = params["consent_id"]  # noqa: E501
        if "authorisation_id" in params:
            path_params["authorisationId"] = params["authorisation_id"]  # noqa: E501

        query_params = []

        header_params = {}
        if "psu_ip_address" in params:
            header_params["PsuIpAddress"] = params["psu_ip_address"]  # noqa: E501
        if "x_request_id" in params:
            header_params["X-Request-ID"] = params["x_request_id"]  # noqa: E501
        if "message_create_date_time" in params:
            header_params["MessageCreateDateTime"] = params["message_create_date_time"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["Authorization"]  # noqa: E501

        return self.api_client.call_api(
            "/psus/{psuId}/consents/{consentId}/authorisations/{authorisationId}",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="ConsentAuthorisationUpdateResponse",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def balances(
        self,
        psu_id,
        aspsp_id,
        account_id,
        x_request_id,
        message_create_date_time,
        **kwargs,
    ):  # noqa: E501
        """Get balances for a specific PSU's account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.balances(psu_id, aspsp_id, account_id, x_request_id, message_create_date_time, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str psu_id: This field can be filled with an ID from the Initiating Party which refers to the PSU.  (required)
        :param str aspsp_id: ASPSP ID.  (required)
        :param str account_id: Id of the account of the PSU as retrieved form the GET accounts response.  (required)
        :param str x_request_id: UUID for unique request identification.  (required)
        :param datetime message_create_date_time: The message create date time.  ISO 8601 DateTime.  (required)
        :param str page: Used to retrieve a specific page in case the result is  paginated. The value can be first, last, prev, next or a  numerical value to request for a dedicated result page.
        :param int total_pages: Used to limit the number of total pages retrieved by one request, if the result is paginated by the ASPSP.
        :param str psu_ip_address: PSU Session information.  The forwarded IP Address header field consists of the corresponding HTTP request IP Address field between PSU and TPP . It shall be contained if and only if this request was actively initiated by the PSU.
        :return: GetBalancesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.balances_with_http_info(
                psu_id,
                aspsp_id,
                account_id,
                x_request_id,
                message_create_date_time,
                **kwargs,
            )  # noqa: E501
        else:
            (data) = self.balances_with_http_info(
                psu_id,
                aspsp_id,
                account_id,
                x_request_id,
                message_create_date_time,
                **kwargs,
            )  # noqa: E501
            return data

    def balances_with_http_info(
        self,
        psu_id,
        aspsp_id,
        account_id,
        x_request_id,
        message_create_date_time,
        **kwargs,
    ):  # noqa: E501
        """Get balances for a specific PSU's account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.balances_with_http_info(psu_id, aspsp_id, account_id, x_request_id, message_create_date_time, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str psu_id: This field can be filled with an ID from the Initiating Party which refers to the PSU.  (required)
        :param str aspsp_id: ASPSP ID.  (required)
        :param str account_id: Id of the account of the PSU as retrieved form the GET accounts response.  (required)
        :param str x_request_id: UUID for unique request identification.  (required)
        :param datetime message_create_date_time: The message create date time.  ISO 8601 DateTime.  (required)
        :param str page: Used to retrieve a specific page in case the result is  paginated. The value can be first, last, prev, next or a  numerical value to request for a dedicated result page.
        :param int total_pages: Used to limit the number of total pages retrieved by one request, if the result is paginated by the ASPSP.
        :param str psu_ip_address: PSU Session information.  The forwarded IP Address header field consists of the corresponding HTTP request IP Address field between PSU and TPP . It shall be contained if and only if this request was actively initiated by the PSU.
        :return: GetBalancesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "psu_id",
            "aspsp_id",
            "account_id",
            "x_request_id",
            "message_create_date_time",
            "page",
            "total_pages",
            "psu_ip_address",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method balances" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'psu_id' is set
        if "psu_id" not in params or params["psu_id"] is None:
            raise ValueError(
                "Missing the required parameter `psu_id` when calling `balances`"
            )  # noqa: E501
        # verify the required parameter 'aspsp_id' is set
        if "aspsp_id" not in params or params["aspsp_id"] is None:
            raise ValueError(
                "Missing the required parameter `aspsp_id` when calling `balances`"
            )  # noqa: E501
        # verify the required parameter 'account_id' is set
        if "account_id" not in params or params["account_id"] is None:
            raise ValueError(
                "Missing the required parameter `account_id` when calling `balances`"
            )  # noqa: E501
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling `balances`"
            )  # noqa: E501
        # verify the required parameter 'message_create_date_time' is set
        if (
            "message_create_date_time" not in params
            or params["message_create_date_time"] is None
        ):
            raise ValueError(
                "Missing the required parameter `message_create_date_time` when calling `balances`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "psu_id" in params:
            path_params["psuId"] = params["psu_id"]  # noqa: E501
        if "aspsp_id" in params:
            path_params["aspspId"] = params["aspsp_id"]  # noqa: E501
        if "account_id" in params:
            path_params["accountId"] = params["account_id"]  # noqa: E501

        query_params = []
        if "page" in params:
            query_params.append(("page", params["page"]))  # noqa: E501
        if "total_pages" in params:
            query_params.append(("totalPages", params["total_pages"]))  # noqa: E501

        header_params = {}
        if "psu_ip_address" in params:
            header_params["PsuIpAddress"] = params["psu_ip_address"]  # noqa: E501
        if "x_request_id" in params:
            header_params["X-Request-ID"] = params["x_request_id"]  # noqa: E501
        if "message_create_date_time" in params:
            header_params["MessageCreateDateTime"] = params["message_create_date_time"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["Authorization"]  # noqa: E501

        return self.api_client.call_api(
            "/psus/{psuId}/aspsps/{aspspId}/accounts/{accountId}/balances",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="GetBalancesResponse",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def consent_extended(
        self, x_request_id, message_create_date_time, psu_id, **kwargs
    ):  # noqa: E501
        """Initiates the consent request, with additional options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.consent_extended(x_request_id, message_create_date_time, psu_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: UUID for unique request identification.  (required)
        :param datetime message_create_date_time: The message create date time.  ISO 8601 DateTime.  (required)
        :param str psu_id: This field can be filled with an ID from the Initiating Party which refers to the PSU.  (required)
        :param ConsentRequest body:
        :param str initiating_party_notification_url: The URL which will be used for notification service requests. The Open Banking Service supports two ways in which this field can be filled: * **Option A)** with an URL ending on /v2 or /v3, indicating the version of the Notification API implemented by the Initiating Party. In this case the URL called for notifications will be extended with /notification/status by the Open Banking Service. The 'NotificationVersion' field MUST NOT be filled. * **Option B)** with a full URL. The version information MUST BE provided in the 'NotificationVersion' field. In this case the provided URL will not be extended, and used as-is.
        :param str notification_version: The version which shall be used for notification service requests. The version is either v2 or v3.  If the NotificationVersion is given: -  The URLs for notification endpoints must be provided as full URLs. -  No endpoint specific extension will be added when calling out for notifications.  See the description of InitiatingPartyNotificationUrl for more information.
        :param str initiating_party_return_url: The callback URL for the redirection back to the Initiating Party after authorization.
        :param bool use_authorisation_landing_pages: If true, the Bank Selection Interface provided by Open Banking Service will be used to request required information from the PSU directly.
        :param str locale: 2-digit ISO-639 code for the language in which the Bank Selection Interface is displayed.  For special languages can be used 5-digit code like nl-BE, where first is ISO-639 langauge code and the second is ISO-3166 country code.  If not set, the language of the Bank Selection Interface is taken over from the end user’s browser configuration or the system configuration of the Bank Selection Interface server.
        :param bool app_redirect_preferred: If set to 'true' the Open Banking Service will try to steer the flow towards an App redirect for the authentication of the PSU and authorization of the consent. This can potentially improve the user journey as the banking application may use biometrics for SCA and skip the identification process if the user is already logged in.  NOTE that, depending on the implementation of the ASPSP, it may so happen that the flows breaks if the user does not have the banking application installed on their mobile device.
        :param datetime last_login: PSU Session information.  The time when the PSU last logged in with the TPP.
        :param str psu_ip_address: PSU Session information.  The forwarded IP Address header field consists of the corresponding HTTP request IP Address field between PSU and TPP . It shall be contained if and only if this request was actively initiated by the PSU.
        :param str psu_ip_port: PSU Session information.  The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
        :param str http_method: PSU Session information.  HTTP method used at the PSU-TPP interface. Available values - GET, POST, PUT, DELETE.
        :param str http_header_user_agent: PSU Session information.  The forwarded Agent header field of the HTTP request between PSU and TPP.
        :param str http_header_referer: PSU Session information.
        :param str http_header_accept: PSU Session information.  The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP.
        :param str http_header_accept_charset: PSU Session information.  The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP.
        :param str http_header_accept_encoding: PSU Session information.  The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP.
        :param str http_header_accept_language: PSU Session information.  The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP.
        :param str device_id: UUID (Universally Unique Identifier) for a device, which is used by the PSU. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.
        :param str geo_location: The forwarded Geo Location of the corresponding http request between PSU and TPP.
        :param bool use_implicit_pre_auth_combined: If set to 'true' and supported by the ASPSP, the Open Banking Service  will request combined pre-authentication for both AIS and PIS.   In use cases where AIS data retrieval is followed by a payment  initiation for the same PSU-ASPSP combination, this can streamline the  process by reducing the authentication steps required for the PSU to a  single step.
        :return: ConsentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.consent_extended_with_http_info(
                x_request_id, message_create_date_time, psu_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.consent_extended_with_http_info(
                x_request_id, message_create_date_time, psu_id, **kwargs
            )  # noqa: E501
            return data

    def consent_extended_with_http_info(
        self, x_request_id, message_create_date_time, psu_id, **kwargs
    ):  # noqa: E501
        """Initiates the consent request, with additional options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.consent_extended_with_http_info(x_request_id, message_create_date_time, psu_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: UUID for unique request identification.  (required)
        :param datetime message_create_date_time: The message create date time.  ISO 8601 DateTime.  (required)
        :param str psu_id: This field can be filled with an ID from the Initiating Party which refers to the PSU.  (required)
        :param ConsentRequest body:
        :param str initiating_party_notification_url: The URL which will be used for notification service requests. The Open Banking Service supports two ways in which this field can be filled: * **Option A)** with an URL ending on /v2 or /v3, indicating the version of the Notification API implemented by the Initiating Party. In this case the URL called for notifications will be extended with /notification/status by the Open Banking Service. The 'NotificationVersion' field MUST NOT be filled. * **Option B)** with a full URL. The version information MUST BE provided in the 'NotificationVersion' field. In this case the provided URL will not be extended, and used as-is.
        :param str notification_version: The version which shall be used for notification service requests. The version is either v2 or v3.  If the NotificationVersion is given: -  The URLs for notification endpoints must be provided as full URLs. -  No endpoint specific extension will be added when calling out for notifications.  See the description of InitiatingPartyNotificationUrl for more information.
        :param str initiating_party_return_url: The callback URL for the redirection back to the Initiating Party after authorization.
        :param bool use_authorisation_landing_pages: If true, the Bank Selection Interface provided by Open Banking Service will be used to request required information from the PSU directly.
        :param str locale: 2-digit ISO-639 code for the language in which the Bank Selection Interface is displayed.  For special languages can be used 5-digit code like nl-BE, where first is ISO-639 langauge code and the second is ISO-3166 country code.  If not set, the language of the Bank Selection Interface is taken over from the end user’s browser configuration or the system configuration of the Bank Selection Interface server.
        :param bool app_redirect_preferred: If set to 'true' the Open Banking Service will try to steer the flow towards an App redirect for the authentication of the PSU and authorization of the consent. This can potentially improve the user journey as the banking application may use biometrics for SCA and skip the identification process if the user is already logged in.  NOTE that, depending on the implementation of the ASPSP, it may so happen that the flows breaks if the user does not have the banking application installed on their mobile device.
        :param datetime last_login: PSU Session information.  The time when the PSU last logged in with the TPP.
        :param str psu_ip_address: PSU Session information.  The forwarded IP Address header field consists of the corresponding HTTP request IP Address field between PSU and TPP . It shall be contained if and only if this request was actively initiated by the PSU.
        :param str psu_ip_port: PSU Session information.  The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
        :param str http_method: PSU Session information.  HTTP method used at the PSU-TPP interface. Available values - GET, POST, PUT, DELETE.
        :param str http_header_user_agent: PSU Session information.  The forwarded Agent header field of the HTTP request between PSU and TPP.
        :param str http_header_referer: PSU Session information.
        :param str http_header_accept: PSU Session information.  The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP.
        :param str http_header_accept_charset: PSU Session information.  The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP.
        :param str http_header_accept_encoding: PSU Session information.  The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP.
        :param str http_header_accept_language: PSU Session information.  The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP.
        :param str device_id: UUID (Universally Unique Identifier) for a device, which is used by the PSU. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID need to be unaltered until removal from device.
        :param str geo_location: The forwarded Geo Location of the corresponding http request between PSU and TPP.
        :param bool use_implicit_pre_auth_combined: If set to 'true' and supported by the ASPSP, the Open Banking Service  will request combined pre-authentication for both AIS and PIS.   In use cases where AIS data retrieval is followed by a payment  initiation for the same PSU-ASPSP combination, this can streamline the  process by reducing the authentication steps required for the PSU to a  single step.
        :return: ConsentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "x_request_id",
            "message_create_date_time",
            "psu_id",
            "body",
            "initiating_party_notification_url",
            "notification_version",
            "initiating_party_return_url",
            "use_authorisation_landing_pages",
            "locale",
            "app_redirect_preferred",
            "last_login",
            "psu_ip_address",
            "psu_ip_port",
            "http_method",
            "http_header_user_agent",
            "http_header_referer",
            "http_header_accept",
            "http_header_accept_charset",
            "http_header_accept_encoding",
            "http_header_accept_language",
            "device_id",
            "geo_location",
            "use_implicit_pre_auth_combined",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method consent_extended" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling `consent_extended`"
            )  # noqa: E501
        # verify the required parameter 'message_create_date_time' is set
        if (
            "message_create_date_time" not in params
            or params["message_create_date_time"] is None
        ):
            raise ValueError(
                "Missing the required parameter `message_create_date_time` when calling `consent_extended`"
            )  # noqa: E501
        # verify the required parameter 'psu_id' is set
        if "psu_id" not in params or params["psu_id"] is None:
            raise ValueError(
                "Missing the required parameter `psu_id` when calling `consent_extended`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "psu_id" in params:
            path_params["psuId"] = params["psu_id"]  # noqa: E501

        query_params = []

        header_params = {}
        if "x_request_id" in params:
            header_params["X-Request-ID"] = params["x_request_id"]  # noqa: E501
        if "message_create_date_time" in params:
            header_params["MessageCreateDateTime"] = params["message_create_date_time"]  # noqa: E501
        if "initiating_party_notification_url" in params:
            header_params["InitiatingPartyNotificationUrl"] = params[
                "initiating_party_notification_url"
            ]  # noqa: E501
        if "notification_version" in params:
            header_params["NotificationVersion"] = params["notification_version"]  # noqa: E501
        if "initiating_party_return_url" in params:
            header_params["InitiatingPartyReturnUrl"] = params[
                "initiating_party_return_url"
            ]  # noqa: E501
        if "use_authorisation_landing_pages" in params:
            header_params["UseAuthorisationLandingPages"] = params[
                "use_authorisation_landing_pages"
            ]  # noqa: E501
        if "locale" in params:
            header_params["Locale"] = params["locale"]  # noqa: E501
        if "app_redirect_preferred" in params:
            header_params["AppRedirectPreferred"] = params["app_redirect_preferred"]  # noqa: E501
        if "last_login" in params:
            header_params["LastLogin"] = params["last_login"]  # noqa: E501
        if "psu_ip_address" in params:
            header_params["PsuIpAddress"] = params["psu_ip_address"]  # noqa: E501
        if "psu_ip_port" in params:
            header_params["PsuIpPort"] = params["psu_ip_port"]  # noqa: E501
        if "http_method" in params:
            header_params["HttpMethod"] = params["http_method"]  # noqa: E501
        if "http_header_user_agent" in params:
            header_params["HttpHeaderUserAgent"] = params["http_header_user_agent"]  # noqa: E501
        if "http_header_referer" in params:
            header_params["HttpHeaderReferer"] = params["http_header_referer"]  # noqa: E501
        if "http_header_accept" in params:
            header_params["HttpHeaderAccept"] = params["http_header_accept"]  # noqa: E501
        if "http_header_accept_charset" in params:
            header_params["HttpHeaderAcceptCharset"] = params[
                "http_header_accept_charset"
            ]  # noqa: E501
        if "http_header_accept_encoding" in params:
            header_params["HttpHeaderAcceptEncoding"] = params[
                "http_header_accept_encoding"
            ]  # noqa: E501
        if "http_header_accept_language" in params:
            header_params["HttpHeaderAcceptLanguage"] = params[
                "http_header_accept_language"
            ]  # noqa: E501
        if "device_id" in params:
            header_params["DeviceId"] = params["device_id"]  # noqa: E501
        if "geo_location" in params:
            header_params["GeoLocation"] = params["geo_location"]  # noqa: E501
        if "use_implicit_pre_auth_combined" in params:
            header_params["UseImplicitPreAuthCombined"] = params[
                "use_implicit_pre_auth_combined"
            ]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["Authorization"]  # noqa: E501

        return self.api_client.call_api(
            "/psus/{psuId}/consents",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="ConsentResponse",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def identification(
        self, x_request_id, message_create_date_time, psu_id, consent_id, **kwargs
    ):  # noqa: E501
        """PSU identification request  # noqa: E501

        Use this operation to identify a PSU in a decoupled approach.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.identification(x_request_id, message_create_date_time, psu_id, consent_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: UUID for unique request identification.  (required)
        :param datetime message_create_date_time: The message create date time.  ISO 8601 DateTime.  (required)
        :param str psu_id: This field can be filled with an ID from the Initiating Party which refers to the PSU.  (required)
        :param str consent_id: Id of the consent as received in the response to POST consents.  (required)
        :param ConsentIdentificationRequest body:
        :param str psu_ip_address: PSU Session information.  The forwarded IP Address header field consists of the corresponding HTTP request IP Address field between PSU and TPP . It shall be contained if and only if this request was actively initiated by the PSU.
        :return: ConsentIdentificationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.identification_with_http_info(
                x_request_id, message_create_date_time, psu_id, consent_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.identification_with_http_info(
                x_request_id, message_create_date_time, psu_id, consent_id, **kwargs
            )  # noqa: E501
            return data

    def identification_with_http_info(
        self, x_request_id, message_create_date_time, psu_id, consent_id, **kwargs
    ):  # noqa: E501
        """PSU identification request  # noqa: E501

        Use this operation to identify a PSU in a decoupled approach.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.identification_with_http_info(x_request_id, message_create_date_time, psu_id, consent_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: UUID for unique request identification.  (required)
        :param datetime message_create_date_time: The message create date time.  ISO 8601 DateTime.  (required)
        :param str psu_id: This field can be filled with an ID from the Initiating Party which refers to the PSU.  (required)
        :param str consent_id: Id of the consent as received in the response to POST consents.  (required)
        :param ConsentIdentificationRequest body:
        :param str psu_ip_address: PSU Session information.  The forwarded IP Address header field consists of the corresponding HTTP request IP Address field between PSU and TPP . It shall be contained if and only if this request was actively initiated by the PSU.
        :return: ConsentIdentificationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "x_request_id",
            "message_create_date_time",
            "psu_id",
            "consent_id",
            "body",
            "psu_ip_address",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method identification" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling `identification`"
            )  # noqa: E501
        # verify the required parameter 'message_create_date_time' is set
        if (
            "message_create_date_time" not in params
            or params["message_create_date_time"] is None
        ):
            raise ValueError(
                "Missing the required parameter `message_create_date_time` when calling `identification`"
            )  # noqa: E501
        # verify the required parameter 'psu_id' is set
        if "psu_id" not in params or params["psu_id"] is None:
            raise ValueError(
                "Missing the required parameter `psu_id` when calling `identification`"
            )  # noqa: E501
        # verify the required parameter 'consent_id' is set
        if "consent_id" not in params or params["consent_id"] is None:
            raise ValueError(
                "Missing the required parameter `consent_id` when calling `identification`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "psu_id" in params:
            path_params["psuId"] = params["psu_id"]  # noqa: E501
        if "consent_id" in params:
            path_params["consentId"] = params["consent_id"]  # noqa: E501

        query_params = []

        header_params = {}
        if "psu_ip_address" in params:
            header_params["PsuIpAddress"] = params["psu_ip_address"]  # noqa: E501
        if "x_request_id" in params:
            header_params["X-Request-ID"] = params["x_request_id"]  # noqa: E501
        if "message_create_date_time" in params:
            header_params["MessageCreateDateTime"] = params["message_create_date_time"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["Authorization"]  # noqa: E501

        return self.api_client.call_api(
            "/psus/{psuId}/consents/{consentId}/identification",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="ConsentIdentificationResponse",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def revoke(
        self, psu_id, consent_id, x_request_id, message_create_date_time, **kwargs
    ):  # noqa: E501
        """Revoke the consent for a specific PSU  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke(psu_id, consent_id, x_request_id, message_create_date_time, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str psu_id: This field can be filled with an ID from the Initiating Party which refers to the PSU.  (required)
        :param str consent_id: Id of the consent as received in the response to POST consents.  (required)
        :param str x_request_id: UUID for unique request identification.  (required)
        :param datetime message_create_date_time: The message create date time.  ISO 8601 DateTime.  (required)
        :param str psu_ip_address: PSU Session information.  The forwarded IP Address header field consists of the corresponding HTTP request IP Address field between PSU and TPP . It shall be contained if and only if this request was actively initiated by the PSU.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.revoke_with_http_info(
                psu_id, consent_id, x_request_id, message_create_date_time, **kwargs
            )  # noqa: E501
        else:
            (data) = self.revoke_with_http_info(
                psu_id, consent_id, x_request_id, message_create_date_time, **kwargs
            )  # noqa: E501
            return data

    def revoke_with_http_info(
        self, psu_id, consent_id, x_request_id, message_create_date_time, **kwargs
    ):  # noqa: E501
        """Revoke the consent for a specific PSU  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke_with_http_info(psu_id, consent_id, x_request_id, message_create_date_time, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str psu_id: This field can be filled with an ID from the Initiating Party which refers to the PSU.  (required)
        :param str consent_id: Id of the consent as received in the response to POST consents.  (required)
        :param str x_request_id: UUID for unique request identification.  (required)
        :param datetime message_create_date_time: The message create date time.  ISO 8601 DateTime.  (required)
        :param str psu_ip_address: PSU Session information.  The forwarded IP Address header field consists of the corresponding HTTP request IP Address field between PSU and TPP . It shall be contained if and only if this request was actively initiated by the PSU.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "psu_id",
            "consent_id",
            "x_request_id",
            "message_create_date_time",
            "psu_ip_address",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'" " to method revoke" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'psu_id' is set
        if "psu_id" not in params or params["psu_id"] is None:
            raise ValueError(
                "Missing the required parameter `psu_id` when calling `revoke`"
            )  # noqa: E501
        # verify the required parameter 'consent_id' is set
        if "consent_id" not in params or params["consent_id"] is None:
            raise ValueError(
                "Missing the required parameter `consent_id` when calling `revoke`"
            )  # noqa: E501
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling `revoke`"
            )  # noqa: E501
        # verify the required parameter 'message_create_date_time' is set
        if (
            "message_create_date_time" not in params
            or params["message_create_date_time"] is None
        ):
            raise ValueError(
                "Missing the required parameter `message_create_date_time` when calling `revoke`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "psu_id" in params:
            path_params["psuId"] = params["psu_id"]  # noqa: E501
        if "consent_id" in params:
            path_params["consentId"] = params["consent_id"]  # noqa: E501

        query_params = []

        header_params = {}
        if "psu_ip_address" in params:
            header_params["PsuIpAddress"] = params["psu_ip_address"]  # noqa: E501
        if "x_request_id" in params:
            header_params["X-Request-ID"] = params["x_request_id"]  # noqa: E501
        if "message_create_date_time" in params:
            header_params["MessageCreateDateTime"] = params["message_create_date_time"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["Authorization"]  # noqa: E501

        return self.api_client.call_api(
            "/psus/{psuId}/consents/{consentId}",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def status(
        self, psu_id, consent_id, x_request_id, message_create_date_time, **kwargs
    ):  # noqa: E501
        """Get the status of a consent for a specific PSU  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.status(psu_id, consent_id, x_request_id, message_create_date_time, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str psu_id: This field can be filled with an ID from the Initiating Party which refers to the PSU.  (required)
        :param str consent_id: Id of the consent as received in the response to POST consents.  (required)
        :param str x_request_id: UUID for unique request identification.  (required)
        :param datetime message_create_date_time: The message create date time.  ISO 8601 DateTime.  (required)
        :param str psu_ip_address: PSU Session information.  The forwarded IP Address header field consists of the corresponding HTTP request IP Address field between PSU and TPP . It shall be contained if and only if this request was actively initiated by the PSU.
        :return: ConsentDetailedInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.status_with_http_info(
                psu_id, consent_id, x_request_id, message_create_date_time, **kwargs
            )  # noqa: E501
        else:
            (data) = self.status_with_http_info(
                psu_id, consent_id, x_request_id, message_create_date_time, **kwargs
            )  # noqa: E501
            return data

    def status_with_http_info(
        self, psu_id, consent_id, x_request_id, message_create_date_time, **kwargs
    ):  # noqa: E501
        """Get the status of a consent for a specific PSU  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.status_with_http_info(psu_id, consent_id, x_request_id, message_create_date_time, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str psu_id: This field can be filled with an ID from the Initiating Party which refers to the PSU.  (required)
        :param str consent_id: Id of the consent as received in the response to POST consents.  (required)
        :param str x_request_id: UUID for unique request identification.  (required)
        :param datetime message_create_date_time: The message create date time.  ISO 8601 DateTime.  (required)
        :param str psu_ip_address: PSU Session information.  The forwarded IP Address header field consists of the corresponding HTTP request IP Address field between PSU and TPP . It shall be contained if and only if this request was actively initiated by the PSU.
        :return: ConsentDetailedInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "psu_id",
            "consent_id",
            "x_request_id",
            "message_create_date_time",
            "psu_ip_address",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'" " to method status" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'psu_id' is set
        if "psu_id" not in params or params["psu_id"] is None:
            raise ValueError(
                "Missing the required parameter `psu_id` when calling `status`"
            )  # noqa: E501
        # verify the required parameter 'consent_id' is set
        if "consent_id" not in params or params["consent_id"] is None:
            raise ValueError(
                "Missing the required parameter `consent_id` when calling `status`"
            )  # noqa: E501
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling `status`"
            )  # noqa: E501
        # verify the required parameter 'message_create_date_time' is set
        if (
            "message_create_date_time" not in params
            or params["message_create_date_time"] is None
        ):
            raise ValueError(
                "Missing the required parameter `message_create_date_time` when calling `status`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "psu_id" in params:
            path_params["psuId"] = params["psu_id"]  # noqa: E501
        if "consent_id" in params:
            path_params["consentId"] = params["consent_id"]  # noqa: E501

        query_params = []

        header_params = {}
        if "psu_ip_address" in params:
            header_params["PsuIpAddress"] = params["psu_ip_address"]  # noqa: E501
        if "x_request_id" in params:
            header_params["X-Request-ID"] = params["x_request_id"]  # noqa: E501
        if "message_create_date_time" in params:
            header_params["MessageCreateDateTime"] = params["message_create_date_time"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["Authorization"]  # noqa: E501

        return self.api_client.call_api(
            "/psus/{psuId}/consents/{consentId}/status",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="ConsentDetailedInformation",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def transactions(
        self,
        psu_id,
        aspsp_id,
        account_id,
        x_request_id,
        message_create_date_time,
        **kwargs,
    ):  # noqa: E501
        """Get the list of transactions for a specific PSU's' account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transactions(psu_id, aspsp_id, account_id, x_request_id, message_create_date_time, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str psu_id: This field can be filled with an ID from the Initiating Party which refers to the PSU.  (required)
        :param str aspsp_id: ASPSP ID.  (required)
        :param str account_id: Id of the account of the PSU as retrieved form the GET accounts response.  (required)
        :param str x_request_id: UUID for unique request identification.  (required)
        :param datetime message_create_date_time: The message create date time.  ISO 8601 DateTime.  (required)
        :param str date_from: Date and time. All transactions on this date are included in the result. If no time is filled it will be set to 00:00. If the ASPSP doesn’t support time, the time part is omitted.
        :param str date_to: Date and time, transactions up to this date are included. So transaction on this date are not included in the result.
        :param str page: Used to retrieve a specific page in case the result is  paginated. The value can be first, last, prev, next or a  numerical value to request for a dedicated result page.
        :param int total_pages: Used to limit the number of total pages retrieved by one request, if the result is paginated by the ASPSP.
        :param str psu_ip_address: PSU Session information.  The forwarded IP Address header field consists of the corresponding HTTP request IP Address field between PSU and TPP . It shall be contained if and only if this request was actively initiated by the PSU.
        :return: GetTransactionsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.transactions_with_http_info(
                psu_id,
                aspsp_id,
                account_id,
                x_request_id,
                message_create_date_time,
                **kwargs,
            )  # noqa: E501
        else:
            (data) = self.transactions_with_http_info(
                psu_id,
                aspsp_id,
                account_id,
                x_request_id,
                message_create_date_time,
                **kwargs,
            )  # noqa: E501
            return data

    def transactions_with_http_info(
        self,
        psu_id,
        aspsp_id,
        account_id,
        x_request_id,
        message_create_date_time,
        **kwargs,
    ):  # noqa: E501
        """Get the list of transactions for a specific PSU's' account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transactions_with_http_info(psu_id, aspsp_id, account_id, x_request_id, message_create_date_time, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str psu_id: This field can be filled with an ID from the Initiating Party which refers to the PSU.  (required)
        :param str aspsp_id: ASPSP ID.  (required)
        :param str account_id: Id of the account of the PSU as retrieved form the GET accounts response.  (required)
        :param str x_request_id: UUID for unique request identification.  (required)
        :param datetime message_create_date_time: The message create date time.  ISO 8601 DateTime.  (required)
        :param str date_from: Date and time. All transactions on this date are included in the result. If no time is filled it will be set to 00:00. If the ASPSP doesn’t support time, the time part is omitted.
        :param str date_to: Date and time, transactions up to this date are included. So transaction on this date are not included in the result.
        :param str page: Used to retrieve a specific page in case the result is  paginated. The value can be first, last, prev, next or a  numerical value to request for a dedicated result page.
        :param int total_pages: Used to limit the number of total pages retrieved by one request, if the result is paginated by the ASPSP.
        :param str psu_ip_address: PSU Session information.  The forwarded IP Address header field consists of the corresponding HTTP request IP Address field between PSU and TPP . It shall be contained if and only if this request was actively initiated by the PSU.
        :return: GetTransactionsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "psu_id",
            "aspsp_id",
            "account_id",
            "x_request_id",
            "message_create_date_time",
            "date_from",
            "date_to",
            "page",
            "total_pages",
            "psu_ip_address",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transactions" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'psu_id' is set
        if "psu_id" not in params or params["psu_id"] is None:
            raise ValueError(
                "Missing the required parameter `psu_id` when calling `transactions`"
            )  # noqa: E501
        # verify the required parameter 'aspsp_id' is set
        if "aspsp_id" not in params or params["aspsp_id"] is None:
            raise ValueError(
                "Missing the required parameter `aspsp_id` when calling `transactions`"
            )  # noqa: E501
        # verify the required parameter 'account_id' is set
        if "account_id" not in params or params["account_id"] is None:
            raise ValueError(
                "Missing the required parameter `account_id` when calling `transactions`"
            )  # noqa: E501
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling `transactions`"
            )  # noqa: E501
        # verify the required parameter 'message_create_date_time' is set
        if (
            "message_create_date_time" not in params
            or params["message_create_date_time"] is None
        ):
            raise ValueError(
                "Missing the required parameter `message_create_date_time` when calling `transactions`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "psu_id" in params:
            path_params["psuId"] = params["psu_id"]  # noqa: E501
        if "aspsp_id" in params:
            path_params["aspspId"] = params["aspsp_id"]  # noqa: E501
        if "account_id" in params:
            path_params["accountId"] = params["account_id"]  # noqa: E501

        query_params = []
        if "date_from" in params:
            query_params.append(("dateFrom", params["date_from"]))  # noqa: E501
        if "date_to" in params:
            query_params.append(("dateTo", params["date_to"]))  # noqa: E501
        if "page" in params:
            query_params.append(("page", params["page"]))  # noqa: E501
        if "total_pages" in params:
            query_params.append(("totalPages", params["total_pages"]))  # noqa: E501

        header_params = {}
        if "psu_ip_address" in params:
            header_params["PsuIpAddress"] = params["psu_ip_address"]  # noqa: E501
        if "x_request_id" in params:
            header_params["X-Request-ID"] = params["x_request_id"]  # noqa: E501
        if "message_create_date_time" in params:
            header_params["MessageCreateDateTime"] = params["message_create_date_time"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["Authorization"]  # noqa: E501

        return self.api_client.call_api(
            "/psus/{psuId}/aspsps/{aspspId}/accounts/{accountId}/transactions",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="GetTransactionsResponse",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def transactionsdownload(
        self, psu_id, aspsp_id, account_id, dl, x_request_id, **kwargs
    ):  # noqa: E501
        """Get the list of transactions for a specific PSU's' account as a download  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transactionsdownload(psu_id, aspsp_id, account_id, dl, x_request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str psu_id: This field can be filled with an ID from the Initiating Party which refers to the PSU.  (required)
        :param str aspsp_id: ASPSP ID.  (required)
        :param str account_id: Id of the account of the PSU as retrieved form the GET accounts response.  (required)
        :param str dl: Download ID as given in the download link of GET transactions. (required)
        :param str x_request_id: UUID for unique request identification.  (required)
        :param str psu_ip_address: PSU Session information.  The forwarded IP Address header field consists of the corresponding HTTP request IP Address field between PSU and TPP . It shall be contained if and only if this request was actively initiated by the PSU.
        :return: GetTransactionsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.transactionsdownload_with_http_info(
                psu_id, aspsp_id, account_id, dl, x_request_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.transactionsdownload_with_http_info(
                psu_id, aspsp_id, account_id, dl, x_request_id, **kwargs
            )  # noqa: E501
            return data

    def transactionsdownload_with_http_info(
        self, psu_id, aspsp_id, account_id, dl, x_request_id, **kwargs
    ):  # noqa: E501
        """Get the list of transactions for a specific PSU's' account as a download  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transactionsdownload_with_http_info(psu_id, aspsp_id, account_id, dl, x_request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str psu_id: This field can be filled with an ID from the Initiating Party which refers to the PSU.  (required)
        :param str aspsp_id: ASPSP ID.  (required)
        :param str account_id: Id of the account of the PSU as retrieved form the GET accounts response.  (required)
        :param str dl: Download ID as given in the download link of GET transactions. (required)
        :param str x_request_id: UUID for unique request identification.  (required)
        :param str psu_ip_address: PSU Session information.  The forwarded IP Address header field consists of the corresponding HTTP request IP Address field between PSU and TPP . It shall be contained if and only if this request was actively initiated by the PSU.
        :return: GetTransactionsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "psu_id",
            "aspsp_id",
            "account_id",
            "dl",
            "x_request_id",
            "psu_ip_address",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transactionsdownload" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'psu_id' is set
        if "psu_id" not in params or params["psu_id"] is None:
            raise ValueError(
                "Missing the required parameter `psu_id` when calling `transactionsdownload`"
            )  # noqa: E501
        # verify the required parameter 'aspsp_id' is set
        if "aspsp_id" not in params or params["aspsp_id"] is None:
            raise ValueError(
                "Missing the required parameter `aspsp_id` when calling `transactionsdownload`"
            )  # noqa: E501
        # verify the required parameter 'account_id' is set
        if "account_id" not in params or params["account_id"] is None:
            raise ValueError(
                "Missing the required parameter `account_id` when calling `transactionsdownload`"
            )  # noqa: E501
        # verify the required parameter 'dl' is set
        if "dl" not in params or params["dl"] is None:
            raise ValueError(
                "Missing the required parameter `dl` when calling `transactionsdownload`"
            )  # noqa: E501
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling `transactionsdownload`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "psu_id" in params:
            path_params["psuId"] = params["psu_id"]  # noqa: E501
        if "aspsp_id" in params:
            path_params["aspspId"] = params["aspsp_id"]  # noqa: E501
        if "account_id" in params:
            path_params["accountId"] = params["account_id"]  # noqa: E501

        query_params = []
        if "dl" in params:
            query_params.append(("dl", params["dl"]))  # noqa: E501

        header_params = {}
        if "x_request_id" in params:
            header_params["X-Request-ID"] = params["x_request_id"]  # noqa: E501
        if "psu_ip_address" in params:
            header_params["PsuIpAddress"] = params["psu_ip_address"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["Authorization"]  # noqa: E501

        return self.api_client.call_api(
            "/download/psus/{psuId}/aspsps/{aspspId}/accounts/{accountId}/transactions",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="GetTransactionsResponse",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )
